using ParallelReverseAutoDiff.PRAD;

public class SpatialProbabilityNetwork
{
    private readonly int stateDim;
    private readonly int[] fieldShape;
    private readonly int vectorDim;
    private readonly int bufferSize;
    
    // Core fields
    private PradOp vectorField;        // Learned directional fields for belief tendency
    private PradOp curvatureField;     // Field curvature for belief stability
    private PradOp entropyField;       // Field entropy for uncertainty
    private PradOp alignmentField;     // Field alignment for belief coherence
    private readonly Queue<Tensor> temporalBuffer;  // Historical state buffer

    // Field parameters
    private const float LEARNING_RATE = 0.01f;
    private const float FIELD_DECAY = 0.999f;
    private const float MIN_FIELD_STRENGTH = 1e-6f;
    
    public SpatialProbabilityNetwork(
        int stateDim = 20,
        int[] fieldShape = null,
        int vectorDim = 8,
        int bufferSize = 10)
    {
        this.stateDim = stateDim;
        this.fieldShape = fieldShape ?? new[] { 32, 32 };
        this.vectorDim = vectorDim;
        this.bufferSize = bufferSize;
        
        // Initialize vector field with normalized random values
        var vectorFieldData = new double[fieldShape[0] * fieldShape[1] * vectorDim];
        Random rand = new Random();
        for (int i = 0; i < vectorFieldData.Length; i++)
        {
            vectorFieldData[i] = rand.NextDouble() * 2 - 1;
        }
        var vectorFieldTensor = new Tensor(fieldShape.Concat(new[] { vectorDim }).ToArray(), vectorFieldData);
        vectorField = new PradOp(NormalizeVectorField(vectorFieldTensor));
        
        // Initialize field metrics
        var fieldSize = fieldShape[0] * fieldShape[1];
        curvatureField = new PradOp(new Tensor(fieldShape, new double[fieldSize]));
        entropyField = new PradOp(new Tensor(fieldShape, Enumerable.Repeat(1.0 / fieldSize, fieldSize).ToArray()));
        alignmentField = new PradOp(new Tensor(fieldShape, new double[fieldSize]));
        
        temporalBuffer = new Queue<Tensor>(bufferSize);
    }

    private Tensor NormalizeVectorField(Tensor field)
    {
        // Normalize vectors to unit length
        var shape = field.Shape;
        var result = new double[field.Data.Length];
        
        for (int i = 0; i < shape[0]; i++)
        {
            for (int j = 0; j < shape[1]; j++)
            {
                double sumSquares = 0;
                for (int k = 0; k < vectorDim; k++)
                {
                    var idx = (i * shape[1] * vectorDim) + (j * vectorDim) + k;
                    sumSquares += field.Data[idx] * field.Data[idx];
                }
                var norm = Math.Sqrt(sumSquares);
                
                for (int k = 0; k < vectorDim; k++)
                {
                    var idx = (i * shape[1] * vectorDim) + (j * vectorDim) + k;
                    result[idx] = field.Data[idx] / norm;
                }
            }
        }
        
        return new Tensor(shape, result);
    }

    public class FieldParameters
    {
        public float Curvature { get; set; }     // Stability measure
        public float Entropy { get; set; }       // Uncertainty measure
        public float Alignment { get; set; }     // Coherence measure
    }

    public (PradResult routing, PradResult confidence, FieldParameters fieldParams) RouteState(PradOp state)
    {
        // Add state to temporal buffer
        if (temporalBuffer.Count >= bufferSize)
        {
            temporalBuffer.Dequeue();
        }
        temporalBuffer.Enqueue(state.CurrentTensor);

        // Calculate cosine similarity between state and vector field for routing
        var similarity = state.MatMul(vectorField.Transpose());
        var routing = similarity.Then(PradOp.SoftmaxOp);

        // Calculate local field parameters
        var localParams = CalculateFieldParameters(state, routing);
        
        // Update field metrics
        UpdateFieldMetrics(state, routing, localParams);

        // Calculate routing confidence based on field parameters
        var confidence = CalculateRoutingConfidence(localParams);

        return (routing, confidence, localParams);
    }

    private FieldParameters CalculateFieldParameters(PradOp state, PradResult routing)
    {
        // Calculate local curvature (stability)
        var localCurvature = CalculateLocalCurvature(state, routing);

        // Calculate local entropy (uncertainty)
        var localEntropy = CalculateLocalEntropy(routing);

        // Calculate local alignment (coherence)
        var localAlignment = CalculateLocalAlignment(state, routing);

        return new FieldParameters
        {
            Curvature = localCurvature.Result.Data[0],
            Entropy = localEntropy.Result.Data[0],
            Alignment = localAlignment.Result.Data[0]
        };
    }

    private PradResult CalculateLocalCurvature(PradOp state, PradResult routing)
    {
        // Estimate local field curvature through finite differences
        var epsilon = 1e-5f;
        var deltaCurvature = state.Then(s => {
            var perturbed = new PradOp(s.Result.Add(new Tensor(s.Result.Shape, epsilon)));
            var perturbedRouting = perturbed.MatMul(vectorField.Transpose())
                .Then(PradOp.SoftmaxOp);
            
            // Second derivative approximation
            return routing.Sub(perturbedRouting.Result).Then(PradOp.SquareOp)
                .Then(PradOp.MeanOp).Mul(new Tensor(new[] { 1 }, 1.0f / (epsilon * epsilon)));
        });

        return deltaCurvature;
    }

    private PradResult CalculateLocalEntropy(PradResult routing)
    {
        // Calculate entropy of routing distribution
        return routing.Then(r => {
            var logProbs = r.Then(PradOp.LnOp);
            return r.Mul(logProbs.Result).Then(PradOp.MeanOp).Mul(new Tensor(new[] { 1 }, -1.0));
        });
    }

    private PradResult CalculateLocalAlignment(PradOp state, PradResult routing)
    {
        // Calculate alignment through vector field coherence
        var fieldDirection = vectorField.Then(v => v.MatMul(routing.Result));
        return state.MatMul(fieldDirection.Result).Then(PradOp.MeanOp);
    }

    public class FlowPattern
    {
        public float[] Position { get; set; }
        public float[] FlowDirection { get; set; }
        public float LocalCurvature { get; set; }
        public float LocalEntropy { get; set; }
        public float LocalAlignment { get; set; }
        public float Stability { get; set; }
    }

    public class GeometricField
    {
        public float[] Direction { get; set; }
        public float Strength { get; set; }
        public float LocalCurvature { get; set; }
        public float LocalDivergence { get; set; }
        public float LocalRotation { get; set; }
    }

    private void UpdateFieldMetrics(PradOp state, PradResult routing, FieldParameters localParams)
    {
        // Calculate geometric field properties
        var geometry = CalculateFieldGeometry(state, routing);

        // Update curvature field incorporating geometric properties
        var curvatureUpdate = localParams.Curvature * (1 - FIELD_DECAY) + 
                            geometry.LocalCurvature * LEARNING_RATE;
        curvatureField = new PradOp(
            curvatureField.Mul(new Tensor(curvatureField.CurrentShape, FIELD_DECAY)).Result
            .Add(new Tensor(curvatureField.CurrentShape, curvatureUpdate))
        );

        // Update entropy field with local divergence influence
        var entropyUpdate = localParams.Entropy * (1 - FIELD_DECAY) + 
                          Math.Abs(geometry.LocalDivergence) * LEARNING_RATE;
        entropyField = new PradOp(
            entropyField.Mul(new Tensor(entropyField.CurrentShape, FIELD_DECAY)).Result
            .Add(new Tensor(entropyField.CurrentShape, entropyUpdate))
        );

        // Update alignment field considering field rotation
        var alignmentUpdate = localParams.Alignment * (1 - FIELD_DECAY) + 
                            (1 - Math.Abs(geometry.LocalRotation)) * LEARNING_RATE;
        alignmentField = new PradOp(
            alignmentField.Mul(new Tensor(alignmentField.CurrentShape, FIELD_DECAY)).Result
            .Add(new Tensor(alignmentField.CurrentShape, alignmentUpdate))
        );
    }

    private GeometricField CalculateFieldGeometry(PradOp state, PradResult routing)
    {
        // Calculate field direction and strength
        var fieldDirection = vectorField.MatMul(routing.Result);
        var fieldStrength = routing.Result.Data.Max();

        // Calculate local curvature using finite differences
        var curvature = CalculateLocalCurvature(state, routing);

        // Calculate divergence (spreading/converging of belief flow)
        var divergence = CalculateLocalDivergence(state, routing);

        // Calculate rotation (circular flow patterns)
        var rotation = CalculateLocalRotation(state, routing);

        return new GeometricField
        {
            Direction = fieldDirection.Result.Data,
            Strength = fieldStrength,
            LocalCurvature = curvature.Result.Data[0],
            LocalDivergence = divergence.Result.Data[0],
            LocalRotation = rotation.Result.Data[0]
        };
    }

    private PradResult CalculateLocalDivergence(PradOp state, PradResult routing)
    {
        // Compute divergence using central differences
        var epsilon = 1e-5f;
        return state.Then(s => {
            var gradients = new List<PradResult>();
            for (int i = 0; i < s.Result.Shape[0]; i++)
            {
                var delta = new float[s.Result.Shape[0]];
                delta[i] = epsilon;
                
                var forward = new PradOp(s.Result.Add(new Tensor(delta)));
                var backward = new PradOp(s.Result.Sub(new Tensor(delta)));
                
                var forwardRoute = forward.MatMul(vectorField.Transpose()).Then(PradOp.SoftmaxOp);
                var backwardRoute = backward.MatMul(vectorField.Transpose()).Then(PradOp.SoftmaxOp);
                
                gradients.Add(forwardRoute.Sub(backwardRoute.Result).Mul(new Tensor(new[] { 1 }, 1.0f / (2 * epsilon))));
            }
            
            return gradients.Aggregate((a, b) => a.Add(b.Result)).Then(PradOp.MeanOp);
        });
    }

    private PradResult CalculateLocalRotation(PradOp state, PradResult routing)
    {
        // Calculate curl-like measure of rotational flow
        var epsilon = 1e-5f;
        return state.Then(s => {
            var rotations = new List<PradResult>();
            for (int i = 0; i < s.Result.Shape[0] - 1; i++)
            {
                for (int j = i + 1; j < s.Result.Shape[0]; j++)
                {
                    var deltaI = new float[s.Result.Shape[0]];
                    var deltaJ = new float[s.Result.Shape[0]];
                    deltaI[i] = epsilon;
                    deltaJ[j] = epsilon;
                    
                    var plusI = new PradOp(s.Result.Add(new Tensor(deltaI)));
                    var plusJ = new PradOp(s.Result.Add(new Tensor(deltaJ)));
                    
                    var routeI = plusI.MatMul(vectorField.Transpose()).Then(PradOp.SoftmaxOp);
                    var routeJ = plusJ.MatMul(vectorField.Transpose()).Then(PradOp.SoftmaxOp);
                    
                    rotations.Add(routeI.Sub(routeJ.Result).Then(PradOp.MeanOp));
                }
            }
            
            return rotations.Aggregate((a, b) => a.Add(b.Result)).Then(PradOp.MeanOp);
        });
    }

    public FlowPattern AnalyzeFieldFlow(PradOp state, int steps = 10)
    {
        var currentState = state;
        var history = new List<GeometricField>();
        
        for (int i = 0; i < steps; i++)
        {
            // Get current routing and field parameters
            var (routing, _, fieldParams) = RouteState(currentState);
            var geometry = CalculateFieldGeometry(currentState, routing);
            history.Add(geometry);
            
            // Update state following field flow
            currentState = new PradOp(routing.Result);
        }
        
        // Analyze flow stability and patterns
        return new FlowPattern
        {
            Position = state.Result.Data,
            FlowDirection = history.Last().Direction,
            LocalCurvature = history.Average(g => g.LocalCurvature),
            LocalEntropy = history.Average(g => -Math.Log(g.Strength)),
            LocalAlignment = history.Average(g => 1 - Math.Abs(g.LocalRotation)),
            Stability = CalculateFlowStability(history)
        };
    }

    private float CalculateFlowStability(List<GeometricField> history)
    {
        // Analyze flow consistency over time
        float directionStability = 0;
        float strengthStability = 0;
        float geometricStability = 0;

        for (int i = 1; i < history.Count; i++)
        {
            // Direction consistency
            directionStability += CosineSimilarity(
                history[i].Direction,
                history[i-1].Direction);

            // Strength consistency
            strengthStability += 1 - Math.Abs(
                history[i].Strength - history[i-1].Strength);

            // Geometric consistency (curvature, divergence, rotation)
            geometricStability += 1 - (
                Math.Abs(history[i].LocalCurvature - history[i-1].LocalCurvature) +
                Math.Abs(history[i].LocalDivergence - history[i-1].LocalDivergence) +
                Math.Abs(history[i].LocalRotation - history[i-1].LocalRotation)
            ) / 3;
        }

        // Combine stability measures
        return (directionStability + strengthStability + geometricStability) / 
               (3 * (history.Count - 1));
    }

    private float CosineSimilarity(float[] v1, float[] v2)
    {
        float dot = v1.Zip(v2, (a, b) => a * b).Sum();
        float norm1 = (float)Math.Sqrt(v1.Sum(x => x * x));
        float norm2 = (float)Math.Sqrt(v2.Sum(x => x * x));
        return dot / (norm1 * norm2);
    }

    private PradResult CalculateRoutingConfidence(FieldParameters fieldParams)
    {
        // Calculate confidence incorporating flow stability
        var state = new PradOp(new Tensor(vectorField.CurrentShape, fieldParams.Alignment));
        var flowPattern = AnalyzeFieldFlow(state);

        float confidence = (1 - fieldParams.Entropy) *                // High confidence when entropy is low
                         (1 / (1 + fieldParams.Curvature)) *         // High confidence when curvature is low
                         Math.Abs(fieldParams.Alignment) *           // High confidence when alignment is strong
                         flowPattern.Stability;                      // High confidence when flow is stable

        return new PradOp(new Tensor(new[] { 1 }, confidence));
    }

    public PradResult AmplifyRoute(PradResult route, PradResult confidence)
    {
        // Amplify routing based on confidence
        var amplificationFactor = confidence.Then(c => {
            var base_amp = new Tensor(c.Result.Shape, 2.0); // Base amplification factor
            return c.Then(PradOp.ExpOp).Mul(base_amp);
        });

        return route.Then(r => r.Mul(amplificationFactor.Result));
    }

    public void UpdateFields(PradResult route, PradResult reward, PradOp state)
    {
        // Calculate field parameters for the update
        var (_, _, fieldParams) = RouteState(state);

        // Update vector field using belief-aligned Hebbian learning
        var fieldUpdate = route.Then(r => {
            // Scale learning by field parameters
            float adaptiveLearningRate = LEARNING_RATE * 
                (1 - fieldParams.Entropy) *         // Learn more when certain
                (1 / (1 + fieldParams.Curvature)); // Learn less in unstable regions

            var learningRateTensor = new Tensor(r.Result.Shape, adaptiveLearningRate);
            return r.Mul(reward.Result).Mul(learningRateTensor);
        });

        // Apply weighted update based on alignment
        var alignmentWeight = Math.Abs(fieldParams.Alignment);
        vectorField = new PradOp(
            vectorField.Mul(new Tensor(vectorField.CurrentShape, 1 - alignmentWeight * LEARNING_RATE)).Result
            .Add(fieldUpdate.Result)
        );

        // Normalize the updated field
        vectorField = new PradOp(NormalizeVectorField(vectorField.CurrentTensor));

        // Update field metrics based on the learning outcome
        UpdateFieldMetrics(state, route, fieldParams);

        // Apply belief reinforcement through field coupling
        ApplyBeliefCoupling(route, fieldParams);
    }

    private void ApplyBeliefCoupling(PradResult route, FieldParameters fieldParams)
    {
        // Calculate coupling strength based on field parameters
        float couplingStrength = Math.Max(0, fieldParams.Alignment) * (1 - fieldParams.Entropy);

        // Identify strongly coupled regions in the field
        var coupledRegions = route.Then(r => {
            return r.Result.Data
                .Select(p => p > MIN_FIELD_STRENGTH ? p * couplingStrength : 0)
                .ToArray();
        });

        // Update vector field to reinforce coupled beliefs
        var couplingUpdate = new PradOp(new Tensor(route.Result.Shape, coupledRegions));
        vectorField = new PradOp(
            vectorField.Add(couplingUpdate.Mul(new Tensor(couplingUpdate.CurrentShape, LEARNING_RATE)).Result).Result
        );
    }

    public class FieldMetrics
    {
        public float GlobalEntropy { get; set; }
        public float GlobalCurvature { get; set; }
        public float GlobalAlignment { get; set; }
        public float BeliefStability { get; set; }
        public float CoherenceScore { get; set; }
    }

    public FieldMetrics CalculateFieldMetrics()
    {
        // Calculate global entropy across the field
        var globalEntropy = entropyField.Then(PradOp.MeanOp);

        // Calculate global curvature (stability measure)
        var globalCurvature = curvatureField.Then(PradOp.MeanOp);

        // Calculate global alignment (coherence measure)
        var globalAlignment = alignmentField.Then(PradOp.MeanOp);

        // Calculate belief stability through field smoothness
        var beliefStability = vectorField.Then(v => {
            var laplacian = CalculateFieldLaplacian(v);
            return laplacian.Then(PradOp.MeanOp);
        });

        // Calculate overall coherence through field structure
        var coherence = vectorField.Then(v => {
            var meanVector = v.Then(PradOp.MeanOp);
            var alignment = v.MatMul(meanVector.Result);
            return alignment.Then(PradOp.MeanOp);
        });

        return new FieldMetrics
        {
            GlobalEntropy = globalEntropy.Result.Data[0],
            GlobalCurvature = globalCurvature.Result.Data[0],
            GlobalAlignment = globalAlignment.Result.Data[0],
            BeliefStability = 1.0f / (1.0f + beliefStability.Result.Data[0]),  // Inverse of Laplacian magnitude
            CoherenceScore = coherence.Result.Data[0]
        };
    }

    private PradResult CalculateFieldLaplacian(PradOp field)
    {
        // Compute discrete Laplacian of the field
        // This measures the second spatial derivative, indicating field smoothness
        var shape = field.CurrentShape;
        var laplacian = new double[shape[0] * shape[1]];

        for (int i = 1; i < shape[0] - 1; i++)
        {
            for (int j = 1; j < shape[1] - 1; j++)
            {
                int idx = i * shape[1] + j;
                
                // Center point
                double center = field.CurrentTensor.Data[idx];
                
                // Adjacent points
                double up = field.CurrentTensor.Data[(i-1) * shape[1] + j];
                double down = field.CurrentTensor.Data[(i+1) * shape[1] + j];
                double left = field.CurrentTensor.Data[i * shape[1] + (j-1)];
                double right = field.CurrentTensor.Data[i * shape[1] + (j+1)];
                
                // Discrete Laplacian
                laplacian[idx] = (up + down + left + right - 4 * center);
            }
        }

        return new PradOp(new Tensor(shape, laplacian));
    }
}

---

using ParallelReverseAutoDiff.PRAD;

public class SpatialProbabilityNetwork 
{
    private readonly int stateDim;
    private readonly int[] fieldShape;
    private readonly int vectorDim;
    private readonly int bufferSize;
    
    // Core fields
    private PradOp vectorField;
    private PradOp probabilityField;
    private readonly Queue<Tensor> temporalBuffer;

    // Neural components
    private readonly PolicyNetwork policyNetwork;
    private readonly ReflexNetwork reflexNetwork; 
    private readonly PredictionNetwork predictionNetwork;

    public SpatialProbabilityNetwork(
        int stateDim = 20,
        int[] fieldShape = null,
        int vectorDim = 8,
        int bufferSize = 10)
    {
        this.stateDim = stateDim;
        this.fieldShape = fieldShape ?? new[] { 32, 32 };
        this.vectorDim = vectorDim;
        this.bufferSize = bufferSize;
        
        InitializeFields();
        temporalBuffer = new Queue<Tensor>(bufferSize);

        // Initialize neural components
        policyNetwork = new PolicyNetwork(stateDim);
        reflexNetwork = new ReflexNetwork(stateDim);
        predictionNetwork = new PredictionNetwork(stateDim);
    }

    private class PolicyNetwork 
    {
        private readonly PradOp stateEncoder;
        private readonly PradOp historyEncoder;
        private readonly PradOp attention;
        private readonly PradOp policyHead;
        private readonly PradOp valueHead;

        public PolicyNetwork(int stateDim)
        {
            // State encoding branch
            stateEncoder = new PradOp(InitializeWeights(stateDim, 64));

            // History encoding branch
            historyEncoder = new PradOp(InitializeWeights(stateDim, 64));

            // Multi-head attention 
            attention = new PradOp(InitializeWeights(64, 64));

            // Output heads
            policyHead = new PradOp(InitializeWeights(128, 10));
            valueHead = new PradOp(InitializeWeights(128, 1));
        }

        public (PradResult policy, PradResult value) Forward(PradOp currentState, PradOp history)
        {
            // Encode current state
            var stateEncoded = stateEncoder.MatMul(currentState)
                .Then(PradOp.LeakyReLUOp);

            // Encode history sequence
            var historyEncoded = historyEncoder.MatMul(history)
                .Then(PradOp.LeakyReLUOp);

            // Apply attention
            var attentionWeights = stateEncoded.MatMul(attention)
                .Then(x => x.MatMul(historyEncoded.Transpose().Result))
                .Then(PradOp.SoftmaxOp);

            var attentionOutput = attentionWeights.MatMul(historyEncoded.Result);

            // Combine features
            var combined = stateEncoded.Then(x => {
                var concat = new double[x.Result.Data.Length + attentionOutput.Result.Data.Length];
                x.Result.Data.CopyTo(concat, 0);
                attentionOutput.Result.Data.CopyTo(concat, x.Result.Data.Length);
                return new PradOp(new Tensor(new[] { concat.Length }, concat));
            });

            // Generate outputs
            var policy = combined.MatMul(policyHead)
                .Then(PradOp.SigmoidOp);

            var value = combined.MatMul(valueHead);

            return (policy, value);
        }
    }

    private class ReflexNetwork 
    {
        private readonly PradOp layer1;
        private readonly PradOp layer2;
        private readonly PradOp outputLayer;

        public ReflexNetwork(int stateDim)
        {
            layer1 = new PradOp(InitializeWeights(stateDim, 32));
            layer2 = new PradOp(InitializeWeights(32, 16));
            outputLayer = new PradOp(InitializeWeights(16, 5)); // 5 reflex controls
        }

        public PradResult Forward(PradOp state)
        {
            return state.MatMul(layer1)
                .Then(PradOp.LeakyReLUOp)
                .Then(x => x.MatMul(layer2.Result))
                .Then(PradOp.LeakyReLUOp)
                .Then(x => x.MatMul(outputLayer.Result))
                .Then(PradOp.SigmoidOp);
        }
    }

    private class PredictionNetwork 
    {
        private readonly PradOp sequenceEncoder;
        private readonly PradOp hidden;
        private readonly PradOp outputLayer;

        public PredictionNetwork(int stateDim)
        {
            sequenceEncoder = new PradOp(InitializeWeights(stateDim * 10, 64));
            hidden = new PradOp(InitializeWeights(64, 32));
            outputLayer = new PradOp(InitializeWeights(32, 4)); // [value, confidence, upper, lower]
        }

        public PradResult Forward(PradOp sequence)
        {
            return sequence.MatMul(sequenceEncoder)
                .Then(PradOp.LeakyReLUOp)
                .Then(x => x.MatMul(hidden.Result))
                .Then(PradOp.LeakyReLUOp)
                .Then(x => x.MatMul(outputLayer.Result));
        }
    }

    public (PradResult routingProbs, PradResult policy, PradResult reflexes, PradResult predictions) 
        ProcessState(PradOp state)
    {
        // Route through SPN
        var (routingProbs, confidence) = RouteState(state);
        
        // Get temporal context
        var historyTensor = GetHistoryTensor();

        // Generate policy
        var (policy, value) = policyNetwork.Forward(state, new PradOp(historyTensor));

        // Check reflexes
        var reflexes = reflexNetwork.Forward(state);

        // Make predictions
        var predictions = predictionNetwork.Forward(new PradOp(historyTensor));

        return (routingProbs, policy, reflexes, predictions);
    }

    private Tensor GetHistoryTensor()
    {
        var history = temporalBuffer.ToArray();
        var historyData = new double[bufferSize * stateDim];
        
        for (int i = 0; i < history.Length; i++)
        {
            Array.Copy(history[i].Data, 0, historyData, i * stateDim, stateDim);
        }

        // Pad with zeros if needed
        if (history.Length < bufferSize)
        {
            Array.Clear(historyData, history.Length * stateDim, (bufferSize - history.Length) * stateDim);
        }

        return new Tensor(new[] { bufferSize, stateDim }, historyData);
    }

    private static Tensor InitializeWeights(int inputDim, int outputDim)
    {
        var weights = new double[inputDim * outputDim];
        var random = new Random();
        var stddev = Math.Sqrt(2.0 / (inputDim + outputDim));

        for (int i = 0; i < weights.Length; i++)
        {
            weights[i] = random.NextGaussian(0, stddev);
        }

        return new Tensor(new[] { inputDim, outputDim }, weights);
    }

    // Previous methods remain the same...
}

---

public class SpatialProbabilityNetwork 
{
    // ... existing fields ...

    // For backpropagation and tracking
    private readonly List<PradOp> trainableParameters;
    private readonly EnhancedVAE vaeModel;

    public SpatialProbabilityNetwork(
        EnhancedVAE vae,
        int stateDim = 20,
        int[] fieldShape = null,
        int vectorDim = 8,
        int bufferSize = 10)
    {
        this.vaeModel = vae;
        trainableParameters = new List<PradOp>();
        // ... existing initialization ...
    }

    // Differentiable forward pass that can be used for backprop
    public (PradResult routing, PradResult policy, PradResult value) Forward(PradOp state)
    {
        // Route through either raw state or VAE latent space
        var (routingProbs, confidence) = RouteState(state);
        
        // Get temporal context for policy
        var historyTensor = GetHistoryTensor();
        var (policy, value) = policyNetwork.Forward(state, new PradOp(historyTensor));

        // Track for backprop
        return (routingProbs, policy, value);
    }

    // VAE integration - route using latent space parameters
    public (PradResult routing, PradResult policy) RouteLatent(FieldParameters fieldParams)
    {
        // Project field parameters to routing space
        var latentProjection = ProjectFieldParameters(fieldParams);
        
        // Route through projected space
        var (routingProbs, confidence) = RouteState(latentProjection);
        
        // Generate policy from latent state
        var historyTensor = GetHistoryTensor();
        var (policy, _) = policyNetwork.Forward(latentProjection, new PradOp(historyTensor));

        return (routingProbs, policy);
    }

    private PradOp ProjectFieldParameters(FieldParameters fieldParams)
    {
        // Create field parameter tensor
        var paramTensor = new Tensor(
            new[] { 3 },
            new[] { 
                fieldParams.Curvature,
                fieldParams.Entropy,
                fieldParams.Alignment 
            }
        );

        // Project through learned transformation
        return new PradOp(paramTensor)
            .MatMul(fieldProjector)
            .Then(PradOp.LeakyReLUOp);
    }

    // Backpropagation support
    public void Back(PradResult loss)
    {
        // Backpropagate through all trainable parameters
        loss.Back();

        // Update all parameters using stored gradients
        foreach (var param in trainableParameters)
        {
            if (param.SeedGradient != null)
            {
                // Apply gradient update
                var update = param.SeedGradient.ElementwiseMultiply(
                    new Tensor(param.SeedGradient.Shape, learningRate)
                );
                param.Add(update);
            }
        }
    }

    // Reward-based credit assignment and exploration
    public void UpdateWithReward(float reward, float discountFactor = 0.99f)
    {
        if (temporalBuffer.Count < 2) return;

        // Calculate TD error
        var currentValue = policyNetwork.GetValue(new PradOp(temporalBuffer.Last()));
        var previousValue = policyNetwork.GetValue(new PradOp(temporalBuffer.ElementAt(temporalBuffer.Count - 2)));
        
        var tdError = reward + discountFactor * currentValue.Result.Data[0] - previousValue.Result.Data[0];

        // Update field using TD error
        var fieldUpdate = vectorField.Then(field => {
            var learningRate = new Tensor(field.Result.Shape, 0.01 * Math.Abs(tdError));
            return field.Mul(learningRate);
        });

        vectorField = new PradOp(
            vectorField.Add(fieldUpdate.Result).Result
        );

        // Add exploration noise based on uncertainty
        AddExplorationNoise();
    }

    private void AddExplorationNoise()
    {
        // Calculate current entropy
        var entropy = CalculateFieldEntropy();
        
        // Scale noise by inverse entropy (less noise when more certain)
        var noiseScale = 1.0 / (1.0 + Math.Exp(entropy.Result.Data[0]));
        
        // Add scaled Gaussian noise to vector field
        var noise = new Tensor(vectorField.CurrentShape, 
            Enumerable.Range(0, vectorField.CurrentTensor.Data.Length)
                .Select(_ => Random.Shared.NextGaussian(0, noiseScale))
                .ToArray());

        vectorField = new PradOp(
            vectorField.Add(noise).Result
        );
    }

    // Analytics and diagnostics
    public Dictionary<string, float> GetDiagnostics()
    {
        var fieldEntropy = CalculateFieldEntropy();
        var meanAlignment = CalculateFieldAlignment();
        var reflexActivations = GetReflexActivations();

        return new Dictionary<string, float>
        {
            ["field_entropy"] = fieldEntropy.Result.Data[0],
            ["mean_alignment"] = meanAlignment.Result.Data[0],
            ["reflex_rate"] = reflexActivations,
            ["routing_confidence"] = CalculateRoutingConfidence().Result.Data[0],
            ["exploration_rate"] = CalculateExplorationRate().Result.Data[0]
        };
    }

    private PradResult CalculateFieldAlignment()
    {
        return vectorField.Then(field => {
            var meanVector = field.Then(PradOp.MeanOp);
            return field.MatMul(meanVector.Result)
                .Then(PradOp.MeanOp);
        });
    }

    private float GetReflexActivations()
    {
        // Calculate percentage of states that triggered reflexes
        var recentStates = temporalBuffer.TakeLast(10);
        var activations = recentStates
            .Select(state => reflexNetwork.Forward(new PradOp(state)))
            .Count(result => result.Result.Data.Any(x => x > 0.5));

        return activations / (float)Math.Max(1, recentStates.Count());
    }
}

---

public class SpatialProbabilityNetwork 
{
    // Add fields for world branching
    private readonly List<SpatialProbabilityNetwork> branches;
    private readonly Random random = new Random();
    private float noveltyWeight = 0.1f;
    private float branchDecayRate = 0.95f;

    // Track visited routes for novelty
    private readonly Dictionary<string, int> routeVisits;
    
    public SpatialProbabilityNetwork(
        EnhancedVAE vae,
        int stateDim = 20,
        int[] fieldShape = null,
        int vectorDim = 8,
        int bufferSize = 10,
        SpatialProbabilityNetwork parent = null)
    {
        // Existing initialization...
        
        branches = new List<SpatialProbabilityNetwork>();
        routeVisits = new Dictionary<string, int>();
    }

    public class WorldBranch
    {
        public SpatialProbabilityNetwork Network { get; }
        public float Value { get; private set; }
        public float Probability { get; private set; }
        public FieldParameters InitialState { get; }

        public WorldBranch(
            SpatialProbabilityNetwork network, 
            FieldParameters state,
            float probability)
        {
            Network = network;
            InitialState = state;
            Probability = probability;
            Value = 0;
        }

        public void UpdateValue(float newValue)
        {
            Value = newValue;
            Probability *= branchDecayRate; // Decay branch probability over time
        }
    }

    // World branching support
    public List<WorldBranch> SimulateWorldBranches(FieldParameters currentState, int numBranches = 3)
    {
        var branches = new List<WorldBranch>();

        for (int i = 0; i < numBranches; i++)
        {
            // Create perturbed state for this branch
            var perturbedState = PerturbFieldParameters(currentState);
            
            // Clone current network for this branch
            var branchNetwork = CloneNetwork();
            
            // Calculate branch probability based on perturbation distance
            float branchProb = CalculateBranchProbability(currentState, perturbedState);
            
            branches.Add(new WorldBranch(branchNetwork, perturbedState, branchProb));
        }

        return branches;
    }

    private FieldParameters PerturbFieldParameters(FieldParameters state)
    {
        return new FieldParameters(new Tensor(new[] { 3 }, new[] {
            state.Curvature + random.NextGaussian(0, 0.1),
            state.Entropy + random.NextGaussian(0, 0.1),
            state.Alignment + random.NextGaussian(0, 0.1)
        }));
    }

    private float CalculateBranchProbability(FieldParameters original, FieldParameters perturbed)
    {
        // Calculate probability based on parameter distance
        float distance = (float)Math.Sqrt(
            Math.Pow(original.Curvature - perturbed.Curvature, 2) +
            Math.Pow(original.Entropy - perturbed.Entropy, 2) +
            Math.Pow(original.Alignment - perturbed.Alignment, 2));
            
        return (float)Math.Exp(-distance);
    }

    // Enhanced exploration model
    public class ExplorationState
    {
        public float NoveltyScore { get; set; }
        public float UncertaintyScore { get; set; }
        public float ExplorationRate { get; set; }
    }

    public ExplorationState UpdateExploration(PradOp state)
    {
        // Calculate route signature for novelty tracking
        string routeSignature = CalculateRouteSignature(state);
        
        // Update visit count
        routeVisits[routeSignature] = routeVisits.GetValueOrDefault(routeSignature, 0) + 1;

        // Calculate novelty score
        float noveltyScore = CalculateNoveltyScore(routeSignature);
        
        // Calculate uncertainty from field entropy
        var fieldEntropy = CalculateFieldEntropy();
        float uncertaintyScore = fieldEntropy.Result.Data[0];

        // Combine for exploration rate
        float explorationRate = CombineExplorationFactors(noveltyScore, uncertaintyScore);

        return new ExplorationState
        {
            NoveltyScore = noveltyScore,
            UncertaintyScore = uncertaintyScore,
            ExplorationRate = explorationRate
        };
    }

    private string CalculateRouteSignature(PradOp state)
    {
        // Discretize state into bins for signature
        var discretized = state.CurrentTensor.Data
            .Select(x => Math.Round(x, 2))
            .ToArray();
            
        return string.Join(",", discretized);
    }

    private float CalculateNoveltyScore(string routeSignature)
    {
        int visits = routeVisits[routeSignature];
        return (float)Math.Exp(-visits * noveltyWeight);
    }

    private float CombineExplorationFactors(float novelty, float uncertainty)
    {
        // Dynamically adjust exploration based on both novelty and uncertainty
        float baseRate = 0.1f;
        float noveltyFactor = noveltyWeight * novelty;
        float uncertaintyFactor = (1 - noveltyWeight) * uncertainty;
        
        return baseRate * (noveltyFactor + uncertaintyFactor);
    }

    // Modified routing to incorporate exploration
    public (PradResult probabilities, PradResult confidence) RouteState(PradOp state)
    {
        var (probs, conf) = base.RouteState(state);
        
        // Get exploration state
        var exploration = UpdateExploration(state);
        
        // Inject exploration noise based on exploration rate
        var noisyProbs = AddExplorationNoise(probs, exploration.ExplorationRate);
        
        // Adjust confidence based on exploration
        var adjustedConf = AdjustConfidence(conf, exploration.ExplorationRate);
        
        return (noisyProbs, adjustedConf);
    }

    private PradResult AddExplorationNoise(PradResult probs, float explorationRate)
    {
        var noise = new Tensor(probs.Result.Shape,
            Enumerable.Range(0, probs.Result.Data.Length)
                .Select(_ => random.NextGaussian(0, explorationRate))
                .ToArray());

        return probs.Then(p => p.Add(noise))
            .Then(PradOp.SoftmaxOp); // Renormalize
    }

    private PradResult AdjustConfidence(PradResult confidence, float explorationRate)
    {
        // Lower confidence when exploring
        return confidence.Then(c => 
            c.Mul(new Tensor(c.Result.Shape, 1 - explorationRate)));
    }

    // Analytics expansion for branching and exploration
    public Dictionary<string, float> GetDiagnostics()
    {
        var baseDiagnostics = base.GetDiagnostics();
        
        // Add branching metrics
        baseDiagnostics["active_branches"] = branches.Count;
        baseDiagnostics["mean_branch_value"] = branches.Any() ? 
            branches.Average(b => b.Value) : 0;
        
        // Add exploration metrics
        var exploration = UpdateExploration(new PradOp(temporalBuffer.Last()));
        baseDiagnostics["novelty_score"] = exploration.NoveltyScore;
        baseDiagnostics["uncertainty_score"] = exploration.UncertaintyScore;
        baseDiagnostics["exploration_rate"] = exploration.ExplorationRate;
        
        return baseDiagnostics;
    }
}
